<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[啃透Java并发之内存模型篇]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%95%83%E9%80%8FJava%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AF%87%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[啃透Java并发之死锁篇]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%95%83%E9%80%8FJava%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%AD%BB%E9%94%81%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言​ 在多线程中，我们使用加锁机制来确保线程安全，但如果使用不当，则可能导致死锁。JVM解决死锁问题方面，并不像数据库服务那么强大（数据库系统设计中考虑了检测死锁以及从死锁中恢复），当一组Java线程发生死锁时，”游戏”到此结束，这些线程永远不能再使用了。 死锁的含义​ 当线程A持有锁L并想获得锁M的同时，线程B持有锁M并尝试所得锁L，那么这两个线程将永远的等待下去，这种情况就是最简单的死锁。 死锁产生的四个必要条件 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。 死锁示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.demo1.controller; public class LockTest &#123; private final Object left= new Object(); private final Object right = new Object(); public void test() throws InterruptedException &#123; new Thread(()-&gt;&#123; synchronized (left)&#123; try &#123; Thread.sleep(2000); System.out.println("获得left锁"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("持有left锁，请求获取right"); synchronized (right)&#123; System.out.println("获取right成功"); &#125; &#125; System.out.println("left-right解锁完毕"); &#125;).start(); new Thread(()-&gt;&#123; synchronized (right)&#123; try &#123; Thread.sleep(2000); System.out.println("获得right锁"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("持有right锁，请求获取left锁"); synchronized (left)&#123; System.out.println("成功获取left锁"); &#125; &#125; System.out.println("right-left解锁完毕"); &#125;).start(); &#125; public static void main(String[] args) &#123; LockTest lt = new LockTest(); try &#123; lt.test(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 结果： 1234获得right锁持有right锁，请求获取left锁获得left锁持有left锁，请求获取right 以上是一个简单的死锁例子，产生死锁的原因是因为两个线程试图以不同的顺序来获得相同的锁。如果按照相同的顺序来请求锁，那么就不会出现循环的加锁依赖性，因此就不会产生死锁。 死锁一旦发生，在java中就只能中断程序了，所以我们需要在实际中避免死锁的发生。 死锁的避免 加锁顺序：尽量让线程按照顺序加锁。 加锁时限：尝试使用lock.trylock代替内置锁，当然只是在特定的场合（需要使用到定时锁，或者可中断锁的时候），否则应当优先使用内置锁，内置锁1.6优化后内置锁效率接近显示锁。 加锁资源：避免一个线程在锁内同时占有多个资源，尽量保证每个锁只占有一个资源。 加锁数量：避免一个线程同时获取多个锁（上面的例子就是一个线程获取两个锁），有需要时应该尽量缩小锁的范围，能用同步块加锁就不要用同步方法加锁。尽量使用开放调用（在调用某个方法时不需要持有锁，那么这种调用被称为开放调用）。 感兴趣的朋友可以学习下银行家算法（避免死锁发生的著名算法）]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 负载均衡]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%20Cloud%20Ribbon%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[Spring Cloud Ribbon实现负载均衡负载均衡负载均衡在系统架构中是一个非常重要的角色，在前面大型网站架构学习总结中，可以看到，高可用，伸缩性，性能几个架构要素中，负载均衡都有着很重要的地位，是系统压力缓解，系统扩容的重要手段之一。 服务端负载一般来说，我们讲的负载均衡都是讲服务端负载均衡（不论硬负载还是软负载），比较常见的通过Nginx反向代理来实现负载均衡，例如下面图中所示 客户端负载均衡这次我们所用到的Ribbon其实就是一种客户端负载均衡，与服务端负载均衡不同的是，客户端负载均衡不是通过一个统一的均衡器（Nginx）去均衡的，而是每一个客户端都维护着各自的负载均衡实现，例如下图所示 优势与不足对比 客户端负载均衡：优势主要体现在稳定性高，各个客户端的负载均衡互不影响，例如上面客户端负载均衡中客户端2的Ribbon出问题了，肯定不会影响客户端1的调用的。劣势就是相对的，升级维护成本高，每次要升级的时候，每个客户端的Ribbon都需要升级。 服务端负载均衡：优势主要体现在统一维护成本低，例如上面的服务端负载均衡，只需要升级Nginx就可以了。劣势同样是相对的，一旦故障，影响大。上面服务端负载均衡中，只要Nginx出问题了，整个系统就不能正常访问了。 Spring Cloud整合Ribbon实现负载均衡新建服务名为consumer2的Eureka Client（两个实例）实例11234server.port=1115spring.application.name=consumer2eureka.instance.hostname=localhost1eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 实例21234server.port=1114spring.application.name=consumer2eureka.instance.hostname=localhost1eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 提供的服务接口1234567891011121314151617@RestControllerpublic class HelloController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient client; @RequestMapping(value="/hello",method = RequestMethod.GET) public String index()&#123; ServiceInstance instance = client.getLocalServiceInstance(); logger.info("/hello host:"+instance.getHost()+"server_id"+instance.getServiceId()+"端口："+instance.getPort()); return "hello"; &#125;&#125; consumer2的两个实例已经准备好了，暴露出来的接口，访问会打印出各自对应的端口信息，接下来我们就通过Ribbon来测试负载均衡 新建名为consumer3的Ribbon Erueka Client工程123server.port=1116spring.application.name=consumer3eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ Erueka Client导入Ribbon依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 引入Ribbon123456789101112131415@SpringBootApplication@EnableDiscoveryClientpublic class EurekaRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 这里可以看到，就是在之前用到的RestTemplate对象加上@LoadBalanced注解就达到将Ribbon引入的目的了 测试负载均衡接口12345678910111213141516171819@RestControllerpublic class HelloController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient client; @Autowired RestTemplate restTemplate; @RequestMapping(&quot;/hello&quot;) public String index()&#123; //在这里调用consumer2提供的接口 return restTemplate.getForEntity(&quot;http://consumer2/hello&quot;,String.class).getBody(); &#125;&#125; 接下来我们分别启动consumer2的两个实例（对应实际中的两台服务器），以及一个包含Ribbon的comsumer3实例。启动完成后服务列表如下 访问http://localhost:1116/hello，我们通过浏览器访问5次 consumer2 （1115）实例控制台输出信息 1232018-12-30 23:00:17.557 INFO 11468 --- [nio-1115-exec-3] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：11152018-12-30 23:00:22.898 INFO 11468 --- [nio-1115-exec-5] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：11152018-12-30 23:00:29.584 INFO 11468 --- [nio-1115-exec-7] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：1115 ​ consumer2 （1114）实例控制台输出信息 122018-12-30 23:00:25.757 INFO 12652 --- [nio-1114-exec-3] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：11142018-12-30 23:00:30.086 INFO 12652 --- [nio-1114-exec-4] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：1114 这里可以看到，consumer2 （1115）实例被访问了3次， consumer2 （1114）被访问了2次，由于我们没有配置访问策略，所以默认用的轮询策略，也就证明Ribbon起到负载均衡的作用了。 负载均衡策略这里对上面说的策略补充一下，Ribbon中主要有以下几种策略 随机规则：RandomRule 随机访问一个实例 最可用规则：BestAvailableRule 根据性能，响应速度，空闲程度等计算 轮询规则(Ribbon默认)：RoundRobinRule 多个实例依次轮询访问 重试实现：RetryRule 对内部定义的策略反复尝试 总结Eureka 整合Ribbon后，通过RestTemplate以服务名访问的方式调用就能实现负载均衡，我们不需要关注各应用的ip、端口，这些信息Ribbon都能从Eureka Server的服务列表获取到，在此基础上，实现Ribbon还是挺方便的。]]></content>
      <categories>
        <category>Spring Cloud教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 服务注册和发现]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%20Cloud%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Spring Cloud 服务注册和发现搭建服务注册中心 导入maven依赖1234567891011121314151617181920212223242526272829303132333435&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.19.BUILD-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Edgware.BUILD-SNAPSHOT&lt;/spring-cloud.version&gt; &lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Edgware.BUILD-SNAPSHOT&lt;/spring-cloud.version&gt; &lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 可通过Spring Initializr选择Eureka Server模块生成，要注意下SpringBoot的版本，不同的版本对应不同的Spring Cloud版本，我这里用的是1.5.19。 修改配置文件123456server.port=1111eureka.instance.hostname=localhost#关闭向注册中心注册eureka.client.register-with-eureka=false#关闭从注册中心获取实例eureka.client.fetch-registry=false 由于本身就是服务端，所以不需要向注册中心注册自己本身，服务端的只要职责是维护服务实例，所以也不需要获取服务实例 修改启动类123456789@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 导入依赖后，只需要在启动上面加上@EnableEurekaServer注解就可以了 启动直接启动应用，然后访问http://localhost:1111/就能看到注册中心的界面 此时可以看到实例列表是没有实例的，接下来我们注册一个客户端上去 搭建Eureka客户端导入maven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置文件1234spring.application.name=consumerserver.port=1112#指定注册中心的地址eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 这里只需要指定注册中心的地址就可以了 修改启动类12345678@SpringBootApplication@EnableDiscoveryClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; 这里只需要加上@EnableDiscoveryClient注解就可以了 启动启动Eureka客户端后，我们再次查看注册中心就能发现我们的客户端实例注册上去了 Eureka Server增加安全用户认证在使用Eureka Server的时候，我们直接访问注册中心的页面就能看到所有的实例信息，在生产环境这样肯定是不安全的，不仅如此，我们把Eureka Client注册上去也不需要认证，用户只要知道地址就能达到把自己的服务伪装成同名服务注册上去，这也是很不安全的，Erueka Server对此提供了安全用户认证。 配置访问用户名和密码1234567#添加HTTP basic基本验证security: basic: enabled: true user: name: dailn password: dailn!123 首先我们需要开启安全校验，然后配置用户名和密码 访问注册中心管理页面 可以看到，这里就需要校验用户和密码了，只有校验通过才能访问注册中心管理页面 客户端再次注册1com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server 增加了安全认证后，客户端就注册不上去了，此时我们需要在客户端注册的时候也加上安全认证 123eureka.client.security.basic.user=dailneureka.client.security.basic.password=dailn!123eureka.client.serviceUrl.defaultZone=http://$&#123;eureka.client.security.basic.user&#125;:$&#123;eureka.client.security.basic.password&#125;@localhost:1111/eureka/ 重新启动就能注册成功，在注册中心管理界面也能看到实例了 总结这一篇文章我们简单的学习下服务的注册和发现，只需要导入相关的依赖，修改配置文件和启动类就可以了，最后为了安全起见还给Erureka Server增加了安全认证，下一篇文章在介绍服务端如何实现高可用。]]></content>
      <categories>
        <category>Spring Cloud教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 服务端高可用]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%20Cloud%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring Cloud 服务端高可用背景在上一篇文章中，我们学习了基本的服务注册和发现，在微服务架构这样的分布式环境中，，我们要充分考虑发生故障的情况，我们知道Eureka服务端主要是维护客户端实例，所以高可用尤为重要，不可能说一个服务端挂了，导致所有的客户端都不可用，接下来我们就学习下如何让服务端实现高可用。 高可用注册中心Eureka Server的设计一开始就考虑了高可用的问题，在Eureka的服务治理中，所有服务实例既是服务消费者，也是服务提供者，注册中心也同样如此。之前我们在搭建Eureka Server的时候，有在配置文件中增加 123#不向注册中心注册自己eureka.client.register-with-eureka=falseeureka.client.fetch-registry=false 这里是因为自己本身就是服务提供者，就没必要在这个基础上注册自身了，但是还是可以向其他注册中心以服务的方式注册自己的，这就是Eureka Server实现高可用的方式。 Eureka Server的高可用实际上就是将自己作为服务向其他注册中心注册自己，这样就可以形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。 实现高可用两个Eureka Server的配置这里我们在之前的Eureka Server基础上增加一个注册中心，并且相互注册，下面试两个注册中心的配置 第一个Eureka Server配置1234567server.port=1111#设置主机名eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=false#向Eureka Server 2注册eureka.client.serviceUrl.defaultZone=http://localhost1:1113/eureka/ 第二个Eureka Server配置1234567server.port=1113#设置主机名eureka.instance.hostname=localhost1eureka.client.register-with-eureka=falseeureka.client.fetch-registry=false#向Eureka Server 1注册eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 这里补充下，因为Eureka 是使用主机名注册的，所以我们指定主机名，然后在HOST文件中加上对应关系 12127.0.0.1 localhost127.0.0.1 localhost1 也可以通过指定ip的方式注册 123456789101112131415161718192021222324252627282930313233#### 测试高可用##### 查看各自的注册中心界面接下来我们分别启动两个服务端，查看其注册中心界面访问http://localhost:1111/![1546144811852](https://note.youdao.com/yws/api/personal/file/77CC3862BDC947FA81ABBE109C0449C7?method=download&amp;shareKey=bb9059b8243983535ee5e54f2fa4f4c5)访问http://localhost:1113/![1546144831986](https://note.youdao.com/yws/api/personal/file/83704A6AFE9C44F79E1F72A879D3D451?method=download&amp;shareKey=e754bb77b79d15429a24f64a89f29b86)这里可以看到在**DS Replicas**中，有另外一个注册中心的地址，**DS Replicas**是副本的意思，出现这个就代表成功把自己当做服务注册到另外一个注册中心上面去了。##### 通过客户端来测试高可用我们通过各自的注册中心能够发现副本就代表注册成功了，那么接下来我们就可以通过Eureka Client来测试一波，流程如下1. 开启两个Eureka Server，并且相互注册。2. 开启一个Eureka Client，并且向两个Eureka Server分别注册3. 访问通过**RestTemplate**以服务名的方式能够成功访问客户端自己提供的服务。4. 停止任意一个Eureka Server，再继续访问，看能否成功访问###### Eureka Client配置```propertiesspring.application.name=consumerserver.port=1112#向注册中心注册自己，多个用逗号隔开eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/,http://localhost1:1113/eureka/ 测试Java类1234567891011121314151617181920212223242526/** * @author dailn * @Classname TestController * @Desc * @create 2018-12-30 11:34 **/@RestControllerpublic class TestController &#123; Logger logger = LoggerFactory.getLogger(TestController.class); @Autowired RestTemplate restTemplate; @RequestMapping("/test") public void test()&#123; restTemplate.getForEntity("http://CONSUMER/helloWord",String.class).getBody(); &#125; @RequestMapping("/helloWord") public String helloWord()&#123; logger.info("helloWord"); return "hello word!"; &#125;&#125; 接下来我们再次查看两个注册中心界面 都能看到Eureka Client名为consumer的实例已经注册上来 然后访问测试接口http://localhost:1112/test，观察控制台打印信息 12018-12-30 12:55:24.680 INFO 11084 --- [nio-1112-exec-7] c.d.eureka_client.TestController : helloWord 接下来我们停掉一个服务在观察控制台，为了准确性，我们多访问几次 1232018-12-30 13:00:58.104 INFO 11084 --- [nio-1112-exec-1] c.d.eureka_client.TestController : helloWord2018-12-30 13:01:03.231 INFO 11084 --- [nio-1112-exec-7] c.d.eureka_client.TestController : helloWord2018-12-30 13:01:04.705 INFO 11084 --- [nio-1112-exec-2] c.d.eureka_client.TestController : helloWord 恩，可以看到还是能正常访问，我们切换，停掉另外一个Eureka Server也是同样结果 总结Eureka Server通过注册中心相互注册、同步实例信息、构成集群来实现高可用的，同理，可以推测出Eureka client实现高可用的方式，无非就是改变端口，同一个服务多次注册到注册中心构成集群。客户端集群这里就不在介绍了，等接下来介绍Ribbon的时候在来实现。]]></content>
      <categories>
        <category>Spring Cloud教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
</search>
