<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[啃透Java并发之死锁篇]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%95%83%E9%80%8FJava%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%AD%BB%E9%94%81%E7%AF%87%2F</url>
    <content type="text"><![CDATA[背景​ 在多线程中，我们使用加锁机制来确保线程安全，但如果使用不当，则可能导致死锁。JVM解决死锁问题方面，并不像数据库服务那么强大（数据库系统设计中考虑了检测死锁以及从死锁中恢复），当一组Java线程发生死锁时，”游戏”到此结束，这些线程永远不能再使用了。 死锁的含义​ 当线程A持有锁L并想获得锁M的同时，线程B持有锁M并尝试所得锁L，那么这两个线程将永远的等待下去，这种情况就是最简单的死锁。 死锁产生的四个必要条件 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。 死锁示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.demo1.controller; public class LockTest &#123; private final Object left= new Object(); private final Object right = new Object(); public void test() throws InterruptedException &#123; new Thread(()-&gt;&#123; synchronized (left)&#123; try &#123; Thread.sleep(2000); System.out.println("获得left锁"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("持有left锁，请求获取right"); synchronized (right)&#123; System.out.println("获取right成功"); &#125; &#125; System.out.println("left-right解锁完毕"); &#125;).start(); new Thread(()-&gt;&#123; synchronized (right)&#123; try &#123; Thread.sleep(2000); System.out.println("获得right锁"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("持有right锁，请求获取left锁"); synchronized (left)&#123; System.out.println("成功获取left锁"); &#125; &#125; System.out.println("right-left解锁完毕"); &#125;).start(); &#125; public static void main(String[] args) &#123; LockTest lt = new LockTest(); try &#123; lt.test(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 结果： 1234获得right锁持有right锁，请求获取left锁获得left锁持有left锁，请求获取right 以上是一个简单的死锁例子，产生死锁的原因是因为两个线程试图以不同的顺序来获得相同的锁。如果按照相同的顺序来请求锁，那么就不会出现循环的加锁依赖性，因此就不会产生死锁。 死锁一旦发生，在java中就只能中断程序了，所以我们需要在实际中避免死锁的发生。 死锁的避免 加锁顺序：尽量让线程按照顺序加锁。 加锁时限：尝试使用lock.trylock代替内置锁，当然只是在特定的场合（需要使用到定时锁，或者可中断锁的时候），否则应当优先使用内置锁，内置锁1.6优化后内置锁效率接近显示锁。 加锁资源：避免一个线程在锁内同时占有多个资源，尽量保证每个锁只占有一个资源。 加锁数量：避免一个线程同时获取多个锁（上面的例子就是一个线程获取两个锁），有需要时应该尽量缩小锁的范围，能用同步块加锁就不要用同步方法加锁。尽量使用开放调用（在调用某个方法时不需要持有锁，那么这种调用被称为开放调用）。 感兴趣的朋友可以学习下银行家算法（避免死锁发生的著名算法）]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[啃透Java并发之synchronized篇]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%95%83%E9%80%8FJava%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized%E7%AF%87%2F</url>
    <content type="text"><![CDATA[场景​ 在多线程并发编程中synchronized一直是元老级角色，作为最基本的互斥手段，很多人都会称呼它为重量级锁。 ​ 但是，随着Java SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重了。Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。 三种形式​ 先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。 SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重了。Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchonized括号里配置的对象。 实现原理​ synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。 ​ monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。 ​ 在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。重入是通过锁的计数器来判断的，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。 synchronized 1.5与1.6优化后比较​ 在1.5引入重入锁后（ReentratLock），synchronized与之比较尤为显得相对重量级。synchronized在1.5之前是通过阻塞实现同步，每次必须获得锁然后执行操作，执行完毕释放锁。Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。 以下是通过跟ReentratLock对比，来体现synchrlnized优化后的效率提升。 java对象头​ synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。具体如下图 java对象头的存取结构 在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据。 自旋锁​ 互斥同步对性能最大的影响是阻塞的实现，在多线程程序中，当线程调度临时挂起活跃线程并转而运行另一个线程时，就会频繁的出现上下文切换操作，这种操作带来极大的开销（挂起线程和恢复线程都需要转入内核态中完成），保存和恢复上下文，丢失局部性，并且cpu时间将更多地花在线程调度而不是线程运行上面。 虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。 ​ 自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX：PreBlockSpin来更改。 自适应自旋锁​ 自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。 偏向锁​ 锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark。 偏向锁的撤销： ​ 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark。 偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。 轻量级锁轻量级锁加锁线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 轻量级锁解锁​ Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。 因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。 补充 轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 轻量级在升级成重量级锁之前会先进行一定的自旋（自适应自旋），自旋拿到锁了就能避免线程上下文切换带来的额外开销。但是在一定次数的自旋还没拿到锁就会升级成重量级锁，后续线程堵塞。直到持有锁的线程释放锁唤醒其他线程，被唤醒的线程开启新的夺锁之争。 锁的优缺点对比 总结​ 看完上面各种锁的区别，现在应该可以理解为什么锁只能升级不能降级了（偏向锁状态可以被重置为无锁状态。），各种锁都有各种锁的应用场景，虽然实际场景中不用我们控制，但是理解synchronized的实现原理，对我们实际的开发也是有很大帮助的。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[啃透Java并发之内存模型篇]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%95%83%E9%80%8FJava%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Java 内存模型背景​ 在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。 在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。 定义​ Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。Java内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示。 ​ 结合例子来看，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。 线程A把本地内存A中更新过的共享变量刷新到主内存中去。 线程B到主内存中去读取线程A之前已更新过的共享变量。 内存间交互操作​ 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 这里需要补充一下java并发常被提起3个特性，原子性，可见性，有序性。 原子性​ 提供了互斥访问，同一时刻只能有一个线程来对他进行操作，由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的，如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。java1.5后concurrent包还提供了一些原子变量类来实现原子性（CAS）。 可见性​ 一个线程对主内存的的修改可以及时的被其他线程观察到，Java语言能实现同步性可见性的有了volatile，synchronized和final。 有序性​ 一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。 从上可以看出volatile只能保证可见性和有序性，并不能保证原子性。其中用来保证有序性和可见性的实现也和synchronized存在一定区别，volatile实现可见性和有序性是通过加入内存屏障来实现的，而synchronized则是通过一次控制一个线程执行（串行执行）来实现的，这点要注意区分下。 上面有提到内存屏障和指令重排序，可能有的朋友不了解，下面分别介绍下 内存屏障​ 为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。 指令重排序​ 重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。重排序分3种类型。 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 这8种内存访问操作以及上述规则限定，再加上稍后介绍的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，java语言中还有一个等效判断原则——先行发生原则（happens-before），他是判断数据是否存在竞争，线程是否安全的主要依据。 happens-before原则 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。 volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。 线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。 线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 volatile型变量的特殊规则 当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。 使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 这里有一点需要注意：volatile保证可见性并不是说volatile直接操作主内存，volatile同样存在工作内存的拷贝，但是由于其特殊的操作顺序，所以看起来如同直接在主内存读写一般。 总结java内存模型涉及的知识点基本上是这些内容了，好好理解内存模型就能解决经常遇到的各种内存可见性问题。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 负载均衡]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%20Cloud%20Ribbon%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[Spring Cloud Ribbon实现负载均衡负载均衡负载均衡在系统架构中是一个非常重要的角色，在前面大型网站架构学习总结中，可以看到，高可用，伸缩性，性能几个架构要素中，负载均衡都有着很重要的地位，是系统压力缓解，系统扩容的重要手段之一。 服务端负载一般来说，我们讲的负载均衡都是讲服务端负载均衡（不论硬负载还是软负载），比较常见的通过Nginx反向代理来实现负载均衡，例如下面图中所示 客户端负载均衡这次我们所用到的Ribbon其实就是一种客户端负载均衡，与服务端负载均衡不同的是，客户端负载均衡不是通过一个统一的均衡器（Nginx）去均衡的，而是每一个客户端都维护着各自的负载均衡实现，例如下图所示 优势与不足对比 客户端负载均衡：优势主要体现在稳定性高，各个客户端的负载均衡互不影响，例如上面客户端负载均衡中客户端2的Ribbon出问题了，肯定不会影响客户端1的调用的。劣势就是相对的，升级维护成本高，每次要升级的时候，每个客户端的Ribbon都需要升级。 服务端负载均衡：优势主要体现在统一维护成本低，例如上面的服务端负载均衡，只需要升级Nginx就可以了。劣势同样是相对的，一旦故障，影响大。上面服务端负载均衡中，只要Nginx出问题了，整个系统就不能正常访问了。 Spring Cloud整合Ribbon实现负载均衡新建服务名为consumer2的Eureka Client（两个实例）实例11234server.port=1115spring.application.name=consumer2eureka.instance.hostname=localhost1eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 实例21234server.port=1114spring.application.name=consumer2eureka.instance.hostname=localhost1eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 提供的服务接口1234567891011121314151617@RestControllerpublic class HelloController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient client; @RequestMapping(value="/hello",method = RequestMethod.GET) public String index()&#123; ServiceInstance instance = client.getLocalServiceInstance(); logger.info("/hello host:"+instance.getHost()+"server_id"+instance.getServiceId()+"端口："+instance.getPort()); return "hello"; &#125;&#125; consumer2的两个实例已经准备好了，暴露出来的接口，访问会打印出各自对应的端口信息，接下来我们就通过Ribbon来测试负载均衡 新建名为consumer3的Ribbon Erueka Client工程123server.port=1116spring.application.name=consumer3eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ Erueka Client导入Ribbon依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 引入Ribbon123456789101112131415@SpringBootApplication@EnableDiscoveryClientpublic class EurekaRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 这里可以看到，就是在之前用到的RestTemplate对象加上@LoadBalanced注解就达到将Ribbon引入的目的了 测试负载均衡接口12345678910111213141516171819@RestControllerpublic class HelloController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient client; @Autowired RestTemplate restTemplate; @RequestMapping(&quot;/hello&quot;) public String index()&#123; //在这里调用consumer2提供的接口 return restTemplate.getForEntity(&quot;http://consumer2/hello&quot;,String.class).getBody(); &#125;&#125; 接下来我们分别启动consumer2的两个实例（对应实际中的两台服务器），以及一个包含Ribbon的comsumer3实例。启动完成后服务列表如下 访问http://localhost:1116/hello，我们通过浏览器访问5次 consumer2 （1115）实例控制台输出信息 1232018-12-30 23:00:17.557 INFO 11468 --- [nio-1115-exec-3] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：11152018-12-30 23:00:22.898 INFO 11468 --- [nio-1115-exec-5] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：11152018-12-30 23:00:29.584 INFO 11468 --- [nio-1115-exec-7] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：1115 ​ consumer2 （1114）实例控制台输出信息 122018-12-30 23:00:25.757 INFO 12652 --- [nio-1114-exec-3] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：11142018-12-30 23:00:30.086 INFO 12652 --- [nio-1114-exec-4] c.d.eureka_client1.HelloController : /hello host:localhost1server_idconsumer2端口：1114 这里可以看到，consumer2 （1115）实例被访问了3次， consumer2 （1114）被访问了2次，由于我们没有配置访问策略，所以默认用的轮询策略，也就证明Ribbon起到负载均衡的作用了。 负载均衡策略这里对上面说的策略补充一下，Ribbon中主要有以下几种策略 随机规则：RandomRule 随机访问一个实例 最可用规则：BestAvailableRule 根据性能，响应速度，空闲程度等计算 轮询规则(Ribbon默认)：RoundRobinRule 多个实例依次轮询访问 重试实现：RetryRule 对内部定义的策略反复尝试 总结Eureka 整合Ribbon后，通过RestTemplate以服务名访问的方式调用就能实现负载均衡，我们不需要关注各应用的ip、端口，这些信息Ribbon都能从Eureka Server的服务列表获取到，在此基础上，实现Ribbon还是挺方便的。]]></content>
      <categories>
        <category>Spring Cloud教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 服务注册和发现]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%20Cloud%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Spring Cloud 服务注册和发现搭建服务注册中心 导入maven依赖1234567891011121314151617181920212223242526272829303132333435&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.19.BUILD-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Edgware.BUILD-SNAPSHOT&lt;/spring-cloud.version&gt; &lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Edgware.BUILD-SNAPSHOT&lt;/spring-cloud.version&gt; &lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 可通过Spring Initializr选择Eureka Server模块生成，要注意下SpringBoot的版本，不同的版本对应不同的Spring Cloud版本，我这里用的是1.5.19。 修改配置文件123456server.port=1111eureka.instance.hostname=localhost#关闭向注册中心注册eureka.client.register-with-eureka=false#关闭从注册中心获取实例eureka.client.fetch-registry=false 由于本身就是服务端，所以不需要向注册中心注册自己本身，服务端的只要职责是维护服务实例，所以也不需要获取服务实例 修改启动类123456789@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 导入依赖后，只需要在启动上面加上@EnableEurekaServer注解就可以了 启动直接启动应用，然后访问http://localhost:1111/就能看到注册中心的界面 此时可以看到实例列表是没有实例的，接下来我们注册一个客户端上去 搭建Eureka客户端导入maven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置文件1234spring.application.name=consumerserver.port=1112#指定注册中心的地址eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 这里只需要指定注册中心的地址就可以了 修改启动类12345678@SpringBootApplication@EnableDiscoveryClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; 这里只需要加上@EnableDiscoveryClient注解就可以了 启动启动Eureka客户端后，我们再次查看注册中心就能发现我们的客户端实例注册上去了 Eureka Server增加安全用户认证在使用Eureka Server的时候，我们直接访问注册中心的页面就能看到所有的实例信息，在生产环境这样肯定是不安全的，不仅如此，我们把Eureka Client注册上去也不需要认证，用户只要知道地址就能达到把自己的服务伪装成同名服务注册上去，这也是很不安全的，Erueka Server对此提供了安全用户认证。 配置访问用户名和密码1234567#添加HTTP basic基本验证security: basic: enabled: true user: name: dailn password: dailn!123 首先我们需要开启安全校验，然后配置用户名和密码 访问注册中心管理页面 可以看到，这里就需要校验用户和密码了，只有校验通过才能访问注册中心管理页面 客户端再次注册1com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server 增加了安全认证后，客户端就注册不上去了，此时我们需要在客户端注册的时候也加上安全认证 123eureka.client.security.basic.user=dailneureka.client.security.basic.password=dailn!123eureka.client.serviceUrl.defaultZone=http://$&#123;eureka.client.security.basic.user&#125;:$&#123;eureka.client.security.basic.password&#125;@localhost:1111/eureka/ 重新启动就能注册成功，在注册中心管理界面也能看到实例了 总结这一篇文章我们简单的学习下服务的注册和发现，只需要导入相关的依赖，修改配置文件和启动类就可以了，最后为了安全起见还给Erureka Server增加了安全认证，下一篇文章在介绍服务端如何实现高可用。]]></content>
      <categories>
        <category>Spring Cloud教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 服务端高可用]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%20Cloud%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring Cloud 服务端高可用背景在上一篇文章中，我们学习了基本的服务注册和发现，在微服务架构这样的分布式环境中，，我们要充分考虑发生故障的情况，我们知道Eureka服务端主要是维护客户端实例，所以高可用尤为重要，不可能说一个服务端挂了，导致所有的客户端都不可用，接下来我们就学习下如何让服务端实现高可用。 高可用注册中心Eureka Server的设计一开始就考虑了高可用的问题，在Eureka的服务治理中，所有服务实例既是服务消费者，也是服务提供者，注册中心也同样如此。之前我们在搭建Eureka Server的时候，有在配置文件中增加 123#不向注册中心注册自己eureka.client.register-with-eureka=falseeureka.client.fetch-registry=false 这里是因为自己本身就是服务提供者，就没必要在这个基础上注册自身了，但是还是可以向其他注册中心以服务的方式注册自己的，这就是Eureka Server实现高可用的方式。 Eureka Server的高可用实际上就是将自己作为服务向其他注册中心注册自己，这样就可以形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。 实现高可用两个Eureka Server的配置这里我们在之前的Eureka Server基础上增加一个注册中心，并且相互注册，下面试两个注册中心的配置 第一个Eureka Server配置1234567server.port=1111#设置主机名eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=false#向Eureka Server 2注册eureka.client.serviceUrl.defaultZone=http://localhost1:1113/eureka/ 第二个Eureka Server配置1234567server.port=1113#设置主机名eureka.instance.hostname=localhost1eureka.client.register-with-eureka=falseeureka.client.fetch-registry=false#向Eureka Server 1注册eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 这里补充下，因为Eureka 是使用主机名注册的，所以我们指定主机名，然后在HOST文件中加上对应关系 12127.0.0.1 localhost127.0.0.1 localhost1 也可以通过指定ip的方式注册 123456789101112131415161718192021222324252627282930313233#### 测试高可用##### 查看各自的注册中心界面接下来我们分别启动两个服务端，查看其注册中心界面访问http://localhost:1111/![1546144811852](https://note.youdao.com/yws/api/personal/file/77CC3862BDC947FA81ABBE109C0449C7?method=download&amp;shareKey=bb9059b8243983535ee5e54f2fa4f4c5)访问http://localhost:1113/![1546144831986](https://note.youdao.com/yws/api/personal/file/83704A6AFE9C44F79E1F72A879D3D451?method=download&amp;shareKey=e754bb77b79d15429a24f64a89f29b86)这里可以看到在**DS Replicas**中，有另外一个注册中心的地址，**DS Replicas**是副本的意思，出现这个就代表成功把自己当做服务注册到另外一个注册中心上面去了。##### 通过客户端来测试高可用我们通过各自的注册中心能够发现副本就代表注册成功了，那么接下来我们就可以通过Eureka Client来测试一波，流程如下1. 开启两个Eureka Server，并且相互注册。2. 开启一个Eureka Client，并且向两个Eureka Server分别注册3. 访问通过**RestTemplate**以服务名的方式能够成功访问客户端自己提供的服务。4. 停止任意一个Eureka Server，再继续访问，看能否成功访问###### Eureka Client配置```propertiesspring.application.name=consumerserver.port=1112#向注册中心注册自己，多个用逗号隔开eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/,http://localhost1:1113/eureka/ 测试Java类1234567891011121314151617181920212223242526/** * @author dailn * @Classname TestController * @Desc * @create 2018-12-30 11:34 **/@RestControllerpublic class TestController &#123; Logger logger = LoggerFactory.getLogger(TestController.class); @Autowired RestTemplate restTemplate; @RequestMapping("/test") public void test()&#123; restTemplate.getForEntity("http://CONSUMER/helloWord",String.class).getBody(); &#125; @RequestMapping("/helloWord") public String helloWord()&#123; logger.info("helloWord"); return "hello word!"; &#125;&#125; 接下来我们再次查看两个注册中心界面 都能看到Eureka Client名为consumer的实例已经注册上来 然后访问测试接口http://localhost:1112/test，观察控制台打印信息 12018-12-30 12:55:24.680 INFO 11084 --- [nio-1112-exec-7] c.d.eureka_client.TestController : helloWord 接下来我们停掉一个服务在观察控制台，为了准确性，我们多访问几次 1232018-12-30 13:00:58.104 INFO 11084 --- [nio-1112-exec-1] c.d.eureka_client.TestController : helloWord2018-12-30 13:01:03.231 INFO 11084 --- [nio-1112-exec-7] c.d.eureka_client.TestController : helloWord2018-12-30 13:01:04.705 INFO 11084 --- [nio-1112-exec-2] c.d.eureka_client.TestController : helloWord 恩，可以看到还是能正常访问，我们切换，停掉另外一个Eureka Server也是同样结果 总结Eureka Server通过注册中心相互注册、同步实例信息、构成集群来实现高可用的，同理，可以推测出Eureka client实现高可用的方式，无非就是改变端口，同一个服务多次注册到注册中心构成集群。客户端集群这里就不在介绍了，等接下来介绍Ribbon的时候在来实现。]]></content>
      <categories>
        <category>Spring Cloud教程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
</search>
